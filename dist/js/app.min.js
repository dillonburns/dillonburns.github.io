var windowHeight = window.innerHeight,
  windowWidth = window.innerWidth;

var centerX = windowWidth / 2,
  centerY = windowHeight / 2;

var dx, dy, dmouse, mmX, mmY, mouseDown, mouseDrag;

var objects = [],
  numObjects = 100;

var spriteLocations = [];
var sprites = [];


//System Functions
function preload() { // preload() runs once
  // img = loadImage('assets/laDefense.jpg');
}

function setup() {
  var canvas = createCanvas(windowWidth, windowHeight);
  canvas.parent('p5-holder');
  populateObjects();
  //frameRate(10);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function mouseClicked() {
  //clear();
  //objects = [];
}

//Helper Functions
function updateMouseVars() {
  dx = mouseX - pmouseX;
  dy = mouseY - pmouseY;
  mmX = mouseX - width / 2;
  mmY = mouseY - height / 2;
  dmouse = int(dist(mouseX, mouseY, pmouseX, pmouseY));
}

function populateObjects() {
  var tempObj;
  for (var i = 0; i < numObjects; i++) {
    tempObj = new Jitter();
    objects.push(tempObj);
  }
}

function updateObjects(objects) {
  var gravity;
  if (mouseIsPressed) {
    gravity = createVector(0, -9.8);
  } else {
    gravity = createVector(0, 9.8);
  }

  for (var i = 0; i < objects.length; i++) {
    objects[i].update();
    objects[i].applyForces(gravity);
    objects[i].display();

    objects[i].checkEdges();
  }
}

//Animation Loop
function draw() {
  clear();
  updateMouseVars();
  thing1();
  thing2();
  //thing3();
  updateObjects(objects);

}

function Jitter() {

  this.diameter = random(10, 50);

  this.position = createVector(
    random(this.diameter + 10,
      windowWidth - this.diameter - 10),
    random(this.diameter + 10,
      windowHeight - this.diameter - 10));
  this.velocity = createVector(random(-10, 10), 0);
  this.acceleration = createVector(0, 0);
  this.mass = this.diameter;
  this.restitution = 0.9;
  this.frictionCoefficient = 0.995;
  this.damper = this.diameter * 0.5;
  this.color = 'rgb(0,0,0)';

  this.update = function () {
    this.velocity.add(this.acceleration);
    this.position.add(this.velocity);
    this.acceleration.mult(0);
  };

  this.display = function () {
    fill(this.color);
    ellipse(this.position.x, this.position.y, this.diameter, this.diameter);
  };

  this.applyForces = function (gravity) {
    this.applyGravity(gravity);
    //this.applyFriction();
  }

  this.applyGravity = function (force) {
    var f = p5.Vector.div(force, this.mass);
    this.acceleration.add(f);
  };

  this.applyFriction = function () {
    if (this.position.y == height)
      this.velocity.x *= this.frictionCoefficient;
  };

  this.isOnFloor = function () {
    return (this.position.y > (height - this.damper));
  }

  this.checkEdges = function () {
    var colliding = false;
    if (this.position.y > (height - this.damper)) {
      //bottom edge checking
      this.velocity.y *= -1 * this.restitution;
      this.position.y = (height - this.damper);
      colliding = true;
    }
    if (this.position.y < (0 + this.damper)) {
      //top edge checking
      this.velocity.y *= -1 * this.restitution;
      this.position.y = (0 + this.damper);
      colliding = true;
    }
    if (this.position.x > (width - this.damper)) {
      //right edge checking
      this.velocity.x *= -1 * this.restitution;
      //this.position.x = (width + this.damper);
      colliding = true;
    }
    if (this.position.x < 0 + this.damper) {
      //left edge checking
      this.velocity.x *= -1 * this.restitution;
      //this.position.x = (0 - this.damper);
      colliding = true;
    }

    if (colliding) {
      this.velocity.mult(this.frictionCoefficient);
    }
  }
};

/*
 * Draws 
 */
function thing1() {
  if (dmouse != 0) {
    ellipse(mouseX, mouseY, dmouse, dmouse);
  }
}

/*
 *  Draws a circle out of circles.
 */
function thing2() {
  var rad,
    bradius = 250,
    sradius = 1;
  push();
  translate(windowWidth / 2, windowHeight / 2);
  for (var i = 0; i < 360; i++) {
    rad = radians(i);
    ellipse(sin(rad) * bradius + mmX, cos(rad) * bradius + mmY, sradius*dmouse);
  }
  pop();
}

/*
 *  Draws a certain number of circles , in a circle pattern.
 */
function thing3() {
  var angleStep,
    numCircles = 24,
    theta,
    Px,
    Py,
    r = 25;
  angleStep = 360.0 / numCircles;
  push();
  for (var i = 0; i < numCircles; i++) {
    theta = i * angleStep + mouseX;
    Px = centerX + (dmouse * cos(radians(theta)));
    Py = centerY + (dmouse * sin(radians(theta)));
    ellipse(Px, Py, sqrt(dmouse));
  }
  pop();
}
